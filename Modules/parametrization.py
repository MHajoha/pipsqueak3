from abc import ABC, abstractproperty, abstractmethod
from asyncio import iscoroutine
from enum import Enum, auto
from functools import wraps
from typing import Iterable, Callable, Iterator, Tuple, Any, List, Union, Optional
from uuid import UUID

from Modules.rat import Rat
from Modules.rat_cache import RatCache
from Modules.rat_rescue import Rescue
from config import config
from Modules.context import Context
from Modules.rat_command import log
from utils.ratlib import Platforms


class _EvaluationResult(Enum):
    """
    Values to be returned from implementations of _AbstractParam.evaluate.
    """

    CONTINUE = auto()
    """
    Returned to signify that remaining parameters should be evaluated normally.
    """

    DONE = auto()
    """
    Returned to indicate that no other parameters should be evaluated and the 
    underlying function is ready to be called.
    An implementation returning this value should also make sure that all arguments of the
    :class:`_ArgumentProvider` are consumed. If this is not the case, it will be assumed that the 
    user provided too many arguments.
    """

    CANCEL = auto()
    """
    Returned to indicate that the command invocation should be cancelled altogether, likely due to 
    an error.
    It is the parameter implementations job to inform the user. (Or not.)
    """


class _ArgumentProvider(Iterator[Tuple[str, str]]):
    """
    Object to provide implementors of _AbstractParam.evaluate with the command
    arguments (words[1:]) in a controlled manner.
    """

    def __init__(self, context: Context):
        self._context = context
        self._index = 1
        self._is_at_end = False

    @property
    def context(self) -> Context:
        return self._context

    @property
    def is_at_end(self) -> bool:
        """
        Indicates whether there are more arguments to be consumed.
        Set when all of the arguments were consumed and when arg_eol was consumed once.
        """
        return self._is_at_end

    def next_arg(self) -> str:
        """
        Consumes and returns a single argument given by the user.
        If the returned argument was the last one, is_at_end is set.

        Raises:
            ValueError: if called when no arguments are left
        """
        if self.is_at_end:
            raise ValueError("no arguments are left")
        else:
            result = self.context.words[self._index]
            self._index += 1
            if self._index >= len(self.context.words):
                self._is_at_end = True
            return result

    def next_arg_eol(self) -> str:
        """
        Consumes the text from the next argument to the end of the line.
        Always sets is_at_end.

        Raises:
            ValueError: if called when no arguments are left
        """
        if self.is_at_end:
            raise ValueError("no arguments are left")
        else:
            self._is_at_end = True
            return self.context.words_eol[self._index]

    def __next__(self) -> str:
        """
        Same as next_arg, but raising :exc:`StopIteration` instead of :exc:`ValueError` if no
        arguments are left.
        """
        if self.is_at_end:
            raise StopIteration
        else:
            return self.next_arg()


class _AbstractParam(ABC):
    """Abstract base class for parameters."""
    _usage_name = abstractproperty()

    def __init__(self, optional: bool = False):
        """
        Initializes a new parameter.

        Args:
            optional:
                Indicates that this argument may be omitted. Mandatory parameters may not follow
                optional ones.
        """
        self.optional = optional

    @abstractmethod
    async def evaluate(self, args: _ArgumentProvider, target_args: List[Any]) -> _EvaluationResult:
        """
        Central method of a parameter. Should use *state* to generate arguments, and append them
        to *target_args*.

        Args:
            args: Arguments given by the invoking user in their message.
            target_args:
                List of generated arguments which this method should append to.
                Arguments generated by previous parameters and also be examined.

        Returns:
            _EvaluationResult: A value indicating if and how evaluation of remaining parameters
                               should proceed. The meaning and contract of each value is described
                               in its docstring.
        """
        ...

    def __str__(self):
        """Create a user-friendly representation of the parameter for use in usage strings."""
        return f"[{self._usage_name}]" if self.optional else f"<{self._usage_name}>"

    def __repr__(self):
        """Create a developer-friendly representation of the parameter."""
        return type(self).__name__ + ("(optional)" if self.optional else "()")


class RescueParam(_AbstractParam):
    """
    Supplies the command function with an instance of :class:`Rescue`.

    The raw argument can be either the client name, their IRC nickname, the rescue's board index or
    '@' followed by the rescue's UUID.

    This type of parameter has extra options, see :meth:`__init__`.
    """
    _usage_name = "case"

    def __init__(self, *, create: bool = False, include_creation: bool = False,
                 closed: bool = False,
                 optional: bool = False):
        """
        Initializes a new rescue parameter.

        Args:
            create:
                If this is True, a case will be created if none could be found. The raw argument
                will then be interpreted as the client's name. Doesn't work when the raw
                argument is a number or begins with '@'.
            include_creation:
                If this is True, a boolean of whether or not the case was created
                (see *create*) will be added as well.
            closed:
                If this is True, closed cases will be considered as well. Requires an API
                connection.
            optional:
                If this is True, the argument may be omitted. Mandatory parameters may not
                follow optional ones.
        """
        super().__init__(optional)
        self.create = create
        self.include_creation = include_creation
        self.closed = closed

    async def evaluate(self, args: _ArgumentProvider, target_args: List[Any]) -> _EvaluationResult:
        rescue = None
        arg = args.next_arg()
        if arg.startswith("@"):
            try:
                uuid = UUID(arg[1:])
            except ValueError:
                log.warn(f"Argument for rescue starts with @, but was not a valid "
                         f"UUID: {arg}")
            except IndexError:
                log.warn(f"Argument for rescue is a sole @")
            else:
                rescue = args.context.bot.board.find_by_uuid(uuid)
                if rescue is None:
                    log.debug(f"Could not find a rescue with UUID {uuid}")
                    await args.context.reply(
                        f"{args.context.user.nickname}: Could not find rescue with ID {uuid}!")
                    return _EvaluationResult.CANCEL
                else:
                    target_args.append(rescue)
                    return _EvaluationResult.CONTINUE

        rescue = args.context.bot.board.find_by_name(arg)
        if rescue is None:
            log.info(f"Could not find a rescue for client {arg}")
            await args.context.reply(
                f"{args.context.user.nickname}: Could not find rat '{arg}'!")
            return _EvaluationResult.CANCEL
        else:
            target_args.append(rescue)
            return _EvaluationResult.CONTINUE

    def __repr__(self):
        result = type(self).__name__ + "("
        for flag, name in ((self.create, "create"), (self.include_creation, "include_creation"),
                           (self.closed, "closed"), (self.optional, "optional")):
            if flag:
                result += name + ", "

        return result


class RatParam(_AbstractParam):
    """
    Supplies the command function with an instance of :class:`Rats` found in the rat cache.

    The raw argument can be the rat name, any of their nicknames or '@' followed by the rat's UUID.
    """
    _usage_name = "rat"

    _AUTO_TYPE = type("AUTO", (object,), {})
    AUTO = _AUTO_TYPE()

    def __init__(self, *, platform: Union[Platforms, _AUTO_TYPE, None] = None,
                 optional: bool = False):
        super().__init__(optional)
        self.platform = platform

    def _get_effective_platform(self, target_args: List[Any]) -> Optional[Platforms]:
        if self.platform is self.AUTO:
            for arg in reversed(target_args):
                if isinstance(arg, Rescue) and arg.platform:
                    return arg.platform
            else:
                return None
        else:
            return self.platform

    async def evaluate(self, args: _ArgumentProvider, target_args: List[Any]) -> _EvaluationResult:
        platform = self._get_effective_platform(target_args)

        arg = args.next_arg()
        if arg.startswith("@"):
            try:
                uuid = UUID(arg[1:])
            except ValueError:
                log.warn(f"Argument for rat starts with @, but was not a valid "
                         f"UUID: {arg}")
            except IndexError:
                log.warn(f"Argument for rat is a sole @")
            else:
                found_rat = await RatCache().get_rat_by_uuid(uuid)
                if found_rat is None:
                    log.debug(f"Could not find a rat with UUID {uuid}")
                    await args.context.reply(
                        f"{args.context.user.nickname}: Could not find rat with ID {uuid}!")
                    return _EvaluationResult.CANCEL
                elif platform is not None and found_rat.platform is not platform:
                    log.debug(f"Found rat {found_rat.name} did not have the correct platform "
                              f"{platform.name}. Actual platform: {found_rat.platform.name}")
                    await args.context.reply(f"{args.context.user.nickname}: Rat with ID {uuid} is "
                                             f"not on {platform.name}.")
                    return _EvaluationResult.CANCEL
                else:
                    target_args.append(found_rat)
                    return _EvaluationResult.CONTINUE

        found_rat = await RatCache().get_rat_by_name(arg, platform)
        if found_rat is None:
            if platform is None:
                log.info(f"Could not find a rat with name {arg}")
                await args.context.reply(
                    f"{args.context.user.nickname}: Could not find rat '{arg}'!")
            else:
                log.info(f"Could not find a rat with name {arg} on platform {platform.name}")
                await args.context.reply(f"{args.context.user.nickname}: Could not find rat "
                                         f"'{arg}' on platform {platform.name}!")
            return _EvaluationResult.CANCEL
        else:
            target_args.append(found_rat)
            return _EvaluationResult.CONTINUE


class WordParam(_AbstractParam):
    """
    Simply forwards the raw argument to the underlying command function.
    """
    _usage_name = "word"

    async def evaluate(self, args: _ArgumentProvider, target_args: List[Any]):
        target_args.append(args.next_arg())
        return _EvaluationResult.CONTINUE


class TextParam(_AbstractParam):
    """
    Supplies the command function with the raw argument in question and also everything up to the
    end of the line in a single string argument.
    This Parameter is terminal. No other parameters must follow it.
    """
    _usage_name = "text"

    async def evaluate(self, args: _ArgumentProvider, target_args: List[Any]):
        target_args.append(args.next_arg_eol())
        return _EvaluationResult.DONE


def parametrize(*params: _AbstractParam, usage: str = None):
    """
    Provides underlying command coroutine with predictable and easy-to-use arguments.

    Arguments:
        *params (_BaseParam):
            Parameters, each of which will be translated into one or more arguments. Available are
            :class:`RescueParam`, :class:`RatParam`, :class:`WordParam` and :class:`TextParam`.
            Check their respective documentation for more info.
        usage (str):
            String representing the correct usage of this command. Will be printed if it is used
            incorrectly. If this is omitted, a string will be generated from the parameters.

    Example:
        >>> @parametrize(WordParam(), WordParam(optional=True))
        ... async def some_command(context, rescue1, rescue2_or_none_if_not_provided):
        ...     pass
    """

    if usage is None:
        usage = _generate_usage(params)

    def decorator(fun: Callable):
        @wraps(fun)
        async def wrapper(context: Context, *args):
            state = _ArgumentProvider(context)
            target_args = [context, *args]

            for param in params:
                if state.is_at_end:
                    # no more arguments provided
                    if param.optional:
                        target_args.append(None)
                        continue
                    else:
                        log.debug(f"Mandatory parameter {repr(param)} was omitted in "
                                  f"{context.words[0]}.")
                        await _reply_usage(context, usage)
                        return

                evaluation_result = await param.evaluate(state, target_args)
                if evaluation_result is _EvaluationResult.CONTINUE:
                    continue
                elif evaluation_result is _EvaluationResult.DONE:
                    break
                else:
                    return

            if not state.is_at_end:
                log.debug(f"Command {context.words[0]} called with too many arguments.")
                await _reply_usage(context, usage)
                return

            result = fun(*target_args)
            if iscoroutine(result):
                return await result
            else:
                return result

        return wrapper

    return decorator


def _generate_usage(params: Iterable[_AbstractParam]) -> str:
    result = ""
    for param in params:
        result += str(param)
        result += " "

    return result


def _reply_usage(context: Context, usage: str):
    return context.reply(f"usage: {config['commands']['prefix']}{context.words[0]} {usage}")
